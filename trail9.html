<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>3D Cube Game with Reset on Border Cross</title>
  <style>
    body {
      margin: 0;
      background: #222;
      display: flex;
      align-items: center;
      justify-content: center;
      height: 100vh;
      overflow: hidden;
      flex-direction: column;
    }
    #gameContainer {
      position: relative;
      width: 100vh;
      height: 150vh; /* 100:150 aspect ratio */
      max-height: 95vh;
      max-width: 63.3vw;
      background: #444;
      border-radius: 10px;
      box-shadow: 0 0 20px black;
    }
    canvas {
      display: block;
      width: 100%;
      height: 100%;
      border-radius: 10px;
    }
    #ui {
      position: absolute;
      top: 10px;
      left: 10px;
      color: white;
      font-family: sans-serif;
      background: rgba(0, 0, 0, 0.6);
      padding: 8px 12px;
      border-radius: 6px;
      z-index: 3;
      user-select: none;
    }
    #startScreen, #winScreen {
      position: absolute;
      top: 0; left: 0;
      width: 100%; height: 100%;
      background: rgba(0, 0, 0, 0.85);
      display: flex;
      align-items: center;
      justify-content: center;
      flex-direction: column;
      color: white;
      font-family: sans-serif;
      z-index: 5;
    }
    input, button {
      padding: 10px;
      margin-top: 10px;
      font-size: 16px;
      border-radius: 5px;
      border: none;
    }
    button:hover {
      cursor: pointer;
      background: #555;
      color: white;
    }
  </style>
</head>
<body>

<div id="gameContainer">
  <!-- Start Screen -->
  <div id="startScreen">
    <h1>üéÆ Cube Adventure</h1>
    <p>Enter your name to begin:</p>
    <input type="text" id="playerName" placeholder="Your name" />
    <button onclick="startGame()">Start Game</button>
  </div>

  <!-- Win Screen -->
  <div id="winScreen" style="display: none;">
    <h1>üèÜ Game Complete!</h1>
    <p id="winnerName"></p>
    <button onclick="location.reload()">Play Again</button>
  </div>

  <!-- UI -->
  <div id="ui">Level: 1</div>
</div>

<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
<script>
  // DOM elements
  const message = document.getElementById("ui");
  const startScreen = document.getElementById("startScreen");
  const winScreen = document.getElementById("winScreen");
  const winnerName = document.getElementById("winnerName");
  const container = document.getElementById("gameContainer");

  // Player info and level
  let player = { name: "Player" };
  let currentLevel = 0;

  // Level data: start, goal, platform size (width, depth)
  const levels = [
    { start: { x: 0, z: 0 }, goal: { x: 5, z: 5 }, platform: { w: 15, d: 15 } },
    { start: { x: -5, z: 5 }, goal: { x: 5, z: -5 }, platform: { w: 20, d: 20 } },
    { start: { x: -10, z: -10 }, goal: { x: 10, z: 10 }, platform: { w: 30, d: 30 } },
    { start: { x: 8, z: -8 }, goal: { x: -8, z: 8 }, platform: { w: 25, d: 25 } },
    { start: { x: 0, z: 0 }, goal: { x: 0, z: 10 }, platform: { w: 20, d: 20 } },
    { start: { x: 5, z: 5 }, goal: { x: -5, z: -5 }, platform: { w: 25, d: 25 } },
    { start: { x: -10, z: 0 }, goal: { x: 10, z: 0 }, platform: { w: 35, d: 20 } }
  ];

  // Three.js setup
  const scene = new THREE.Scene();
  scene.background = new THREE.Color(0x87ceeb); // sky blue

  const camera = new THREE.PerspectiveCamera(60, 2/3, 0.1, 1000);
  camera.position.set(8, 15, 20);
  camera.lookAt(0, 0, 0);

  const renderer = new THREE.WebGLRenderer({ antialias: true });
  renderer.setSize(container.clientWidth, container.clientHeight);
  renderer.setPixelRatio(window.devicePixelRatio);
  renderer.shadowMap.enabled = true;
  container.appendChild(renderer.domElement);

  // Lights
  const ambientLight = new THREE.AmbientLight(0xffffff, 0.4);
  scene.add(ambientLight);

  const dirLight = new THREE.DirectionalLight(0xffffff, 0.8);
  dirLight.position.set(20, 40, 20);
  dirLight.castShadow = true;
  dirLight.shadow.mapSize.width = 1024;
  dirLight.shadow.mapSize.height = 1024;
  scene.add(dirLight);

  // Player cube
  const cubeGeometry = new THREE.BoxGeometry(1, 1, 1);
  const cubeMaterial = new THREE.MeshStandardMaterial({ color: 0x00ff00 });
  const cube = new THREE.Mesh(cubeGeometry, cubeMaterial);
  cube.castShadow = true;
  cube.position.y = 0.5;
  scene.add(cube);

  // Goal cube (make bigger and bright)
  const goalGeometry = new THREE.BoxGeometry(1.5, 1.5, 1.5);
  const goalMaterial = new THREE.MeshStandardMaterial({ color: 0xffff00, emissive: 0xffff33, emissiveIntensity: 0.7 });
  const goal = new THREE.Mesh(goalGeometry, goalMaterial);
  goal.castShadow = true;
  goal.position.y = 0.75;
  scene.add(goal);

  // Platform mesh (will be updated each level)
  let platform;
  const platformMaterial = new THREE.MeshStandardMaterial({ color: 0x654321 });
  
  function createPlatform(width, depth) {
    if (platform) scene.remove(platform);
    const geometry = new THREE.BoxGeometry(width, 0.5, depth);
    platform = new THREE.Mesh(geometry, platformMaterial);
    platform.position.y = 0;
    platform.receiveShadow = true;
    scene.add(platform);
  }

  // Ground underneath platform for shadow catch (big)
  const ground = new THREE.Mesh(
    new THREE.PlaneGeometry(100, 100),
    new THREE.ShadowMaterial({ opacity: 0.3 })
  );
  ground.rotation.x = -Math.PI / 2;
  ground.position.y = -0.25;
  ground.receiveShadow = true;
  scene.add(ground);

  // Controls
  const keys = {};
  document.addEventListener("keydown", e => keys[e.key.toLowerCase()] = true);
  document.addEventListener("keyup", e => keys[e.key.toLowerCase()] = false);

  // Movement bounds (updated each level based on platform size)
  let bounds = { minX: 0, maxX: 0, minZ: 0, maxZ: 0 };

  function moveCube() {
    const speed = 0.15;
    let newX = cube.position.x;
    let newZ = cube.position.z;

    if (keys['w'] || keys['arrowup']) newZ -= speed;
    if (keys['s'] || keys['arrowdown']) newZ += speed;
    if (keys['a'] || keys['arrowleft']) newX -= speed;
    if (keys['d'] || keys['arrowright']) newX += speed;

    cube.position.set(newX, 0.5, newZ);

    // Check if cube is outside platform bounds
    if (
      cube.position.x < bounds.minX ||
      cube.position.x > bounds.maxX ||
      cube.position.z < bounds.minZ ||
      cube.position.z > bounds.maxZ
    ) {
      // Reset cube to start position of current level
      const level = levels[currentLevel];
      cube.position.set(level.start.x, 0.5, level.start.z);
    }
  }

  // Fixed loadLevel function with platform centering
  function loadLevel(index) {
    if (index >= levels.length) return;

    const level = levels[index];

    // Calculate platform center as midpoint between start and goal
    const centerX = (level.start.x + level.goal.x) / 2;
    const centerZ = (level.start.z + level.goal.z) / 2;

    // Create platform at center
    createPlatform(level.platform.w, level.platform.d);
    platform.position.set(centerX, 0, centerZ);

    // Calculate bounds based on platform center and size
    bounds.minX = centerX - (level.platform.w / 2) + 0.5;
    bounds.maxX = centerX + (level.platform.w / 2) - 0.5;
    bounds.minZ = centerZ - (level.platform.d / 2) + 0.5;
    bounds.maxZ = centerZ + (level.platform.d / 2) - 0.5;

    // Position cube and goal relative to platform center
    cube.position.set(level.start.x, 0.5, level.start.z);
    goal.position.set(level.goal.x, 0.75, level.goal.z);

    message.textContent = `Level: ${index + 1}`;
  }

  function checkGoal() {
    const dist = cube.position.distanceTo(goal.position);
    if (dist < 1) {
      currentLevel++;
      if (currentLevel >= levels.length) {
        message.style.display = "none";
        winScreen.style.display = "flex";
        winnerName.textContent = `${player.name}, you finished all levels! üéâ`;
      } else {
        loadLevel(currentLevel);
      }
    }
  }

  function animate() {
    requestAnimationFrame(animate);

    moveCube();

    // Smooth camera follow the cube
    const targetPos = new THREE.Vector3(cube.position.x, 0, cube.position.z);
    const camTargetPos = new THREE.Vector3(cube.position.x, cube.position.y + 8, cube.position.z + 15);
    camera.position.lerp(camTargetPos, 0.1);
    camera.lookAt(targetPos);

    checkGoal();

    renderer.render(scene, camera);
  }

  function startGame() {
    const input = document.getElementById("playerName");
    player.name = input.value.trim() || "Player";
    startScreen.style.display = "none";
    message.style.display = "block";
    currentLevel = 0;
    loadLevel(currentLevel);
    animate();
  }

  // Handle window resize
  window.addEventListener('resize', () => {
    const w = container.clientWidth;
    const h = container.clientHeight;
    camera.aspect = w / h;
    camera.updateProjectionMatrix();
    renderer.setSize(w, h);
  });
</script>

</body>
</html>
